# Практическое занятие №1 — Мини веб служба и конвейер обработки запросов

## Описание

Мини веб служба на ASP.NET Core (Minimal API), которая хранит каталог элементов в памяти процесса и демонстрирует конвейер обработки запроса (request pipeline).

**Предметная область** — каталог товаров с полями: идентификатор, название, описание, цена, дата создания.

## Архитектурная идея

Проект построен по принципу **чистого конвейера (pipeline)**: каждый запрос последовательно проходит через цепочку middleware-обработчиков, где каждый шаг решает ровно одну задачу и не знает о деталях остальных.

```
Клиент → RequestIdMiddleware → ErrorHandlingMiddleware → TimingAndLogMiddleware → Endpoint
```

### Почему именно такой конвейер, а не случайный набор функций

1. **RequestIdMiddleware** — первый в цепочке: присваивает каждому запросу уникальный идентификатор (`X-Request-Id`). Это сквозная «нить», по которой можно связать все записи журнала для одного запроса. Если клиент передал свой идентификатор — он сохраняется.

2. **ErrorHandlingMiddleware** — оборачивает всё «ниже» в try/catch. Ловит доменные исключения (`ValidationException`, `NotFoundException`) и непредвиденные ошибки, превращая их в единый JSON-формат: `{ "code", "message", "requestId" }`. Без этого обработчика ошибки «протекали» бы наружу в виде HTML-страниц или пустых 500-ответов.

3. **TimingAndLogMiddleware** — замеряет реальное время выполнения запроса (через `Stopwatch`) и пишет в журнал метод, путь, статус, время и `requestId`.

Порядок регистрации важен: `RequestId` идёт первым, чтобы идентификатор был доступен для всех остальных; `ErrorHandling` идёт до `Timing`, чтобы даже при исключении таймер корректно работал.

### Компоненты на стороне приложения vs. ядро каркаса

| Ядро каркаса (framework)              | Приложение (application)                  |
|---------------------------------------|-------------------------------------------|
| Конвейер middleware (pipeline)        | Конкретные middleware (RequestId, Timing…) |
| Маршрутизация (`MapGet`, `MapPost`)   | Обработчики эндпоинтов, валидация         |
| DI-контейнер                          | Регистрация `IItemRepository`             |
| Сериализация JSON                     | Доменная модель (`Item`, `CreateItemRequest`) |

## Требования

- [.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0)

## Запуск

```bash
cd task1_framework
dotnet run
```

Сервер стартует на `http://localhost:54255` (и `https://localhost:54254`).

## Точки доступа (API)

### GET /api/items — список элементов

Параметры запроса (опциональные):
- `name` — фильтр по подстроке в имени (без учёта регистра)
- `sortBy` — поле сортировки: `name` (по умолчанию), `price`, `date`
- `desc` — `true` для сортировки по убыванию

```bash
curl http://localhost:54255/api/items
curl "http://localhost:54255/api/items?name=ручка&sortBy=price&desc=true"
```

### GET /api/items/{id} — один элемент по идентификатору

```bash
curl http://localhost:54255/api/items/GUID_ЗДЕСЬ
```

### POST /api/items — создание элемента

```bash
curl -X POST http://localhost:54255/api/items \
  -H "Content-Type: application/json" \
  -d '{"name": "Тетрадь", "description": "48 листов, клетка", "price": 45}'
```

## Правила валидации

1. **name** — обязательное, непустое поле
2. **name** — длина не более 200 символов
3. **description** — длина не более 1000 символов
4. **price** — не может быть отрицательным

При нарушении возвращается `400 Bad Request` с JSON:

```json
{
  "code": "validation",
  "message": "Поле name не должно быть пустым",
  "requestId": "abc123..."
}
```

## Единый формат ошибок

Все ошибки (валидация, не найдено, внутренняя ошибка) возвращаются в формате:

```json
{
  "code": "not_found | validation | internal_error",
  "message": "Описание ошибки",
  "requestId": "идентификатор запроса"
}
```

## Запуск тестов

```bash
cd Tests
dotnet test --verbosity normal
```

### Состав тестов (всего 23)

**Юнит-тесты** (`InMemoryItemRepositoryTests`) — 11 тестов:
- Пустое хранилище возвращает пустой список
- Создание элемента возвращает корректный объект с generated ID
- Получение по ID после создания
- Получение несуществующего ID → null
- Список после создания нескольких элементов
- Сортировка по имени по умолчанию
- Фильтрация по подстроке имени
- Сортировка по цене (по возрастанию)
- Сортировка по цене (по убыванию)
- Поле `CreatedAt` устанавливается в актуальное время
- Сортировка по дате создания

**Интеграционные тесты** (`ApiIntegrationTests`) — 12 тестов:
- GET пустого списка → 200 OK
- POST + GET — полный цикл создания и получения
- Валидация пустого имени → 400
- Валидация отрицательной цены → 400
- Валидация слишком длинного имени → 400
- Валидация слишком длинного описания → 400
- GET несуществующего ID → 404 с requestId
- Наличие заголовка X-Request-Id в ответе
- Клиентский X-Request-Id сохраняется
- Фильтрация по имени через query-параметр
- Сортировка по цене через query-параметр
- **Журнал содержит requestId и timeMs** (перехват лога через TestLoggerProvider)

## Ручной прогон сценариев

> Перед началом запустите сервер в **отдельном** терминале:
> ```
> dotnet run
> ```
> Затем откройте **второй** терминал и выполняйте команды ниже по очереди (копировать → вставить → Enter).

### Сценарий 1: Создание элемента

```powershell
Invoke-RestMethod -Uri http://localhost:54255/api/items -Method POST -ContentType 'application/json' -Body '{"name":"Тетрадь","description":"48 листов, клетка","price":45}'
```

Ожидаемый результат: JSON с полями `id`, `name`, `description`, `price`, `createdAt`.

### Сценарий 2: Создание второго элемента

```powershell
Invoke-RestMethod -Uri http://localhost:54255/api/items -Method POST -ContentType 'application/json' -Body '{"name":"Ручка","description":"Шариковая, синяя","price":25}'
```

Ожидаемый результат: новый элемент с другим `id`.

### Сценарий 3: Получение списка всех элементов

```powershell
Invoke-RestMethod -Uri http://localhost:54255/api/items
```

Ожидаемый результат: массив из двух элементов, отсортированных по имени (Ручка, Тетрадь).

### Сценарий 4: Фильтрация по имени

```powershell
Invoke-RestMethod -Uri 'http://localhost:54255/api/items?name=Тетрадь'
```

Ожидаемый результат: массив с одним элементом «Тетрадь».

### Сценарий 5: Сортировка по цене по убыванию

```powershell
Invoke-RestMethod -Uri 'http://localhost:54255/api/items?sortBy=price&desc=true'
```

Ожидаемый результат: первым идёт «Тетрадь» (45), затем «Ручка» (25).

### Сценарий 6: Получение элемента по ID

Скопируйте `id` из ответа сценария 1 и подставьте вместо `ВСТАВЬТЕ_ID`:

```powershell
Invoke-RestMethod -Uri http://localhost:54255/api/items/ВСТАВЬТЕ_ID
```

Ожидаемый результат: JSON одного элемента.

### Сценарий 7: Запрос несуществующего элемента → 404

```powershell
try { Invoke-RestMethod -Uri http://localhost:54255/api/items/00000000-0000-0000-0000-000000000000 } catch { $_.ErrorDetails.Message }
```

Ожидаемый результат:
```json
{"code":"not_found","message":"Элемент с идентификатором 00000000-... не найден","requestId":"..."}
```

### Сценарий 8: Валидация — пустое имя → 400

```powershell
try { Invoke-RestMethod -Uri http://localhost:54255/api/items -Method POST -ContentType 'application/json' -Body '{"name":"","description":"","price":10}' } catch { $_.ErrorDetails.Message }
```

Ожидаемый результат:
```json
{"code":"validation","message":"Поле name не должно быть пустым","requestId":"..."}
```

### Сценарий 9: Валидация — отрицательная цена → 400

```powershell
try { Invoke-RestMethod -Uri http://localhost:54255/api/items -Method POST -ContentType 'application/json' -Body '{"name":"Тест","description":"","price":-5}' } catch { $_.ErrorDetails.Message }
```

Ожидаемый результат:
```json
{"code":"validation","message":"Поле price не может быть отрицательным","requestId":"..."}
```

### Сценарий 10: Проверка заголовка X-Request-Id

```powershell
$r = Invoke-WebRequest -Uri http://localhost:54255/api/items; $r.Headers['X-Request-Id']
```

Ожидаемый результат: строка вида `abc123def456...`

### Сценарий 11: Свой X-Request-Id сохраняется

```powershell
$r = Invoke-WebRequest -Uri http://localhost:54255/api/items -Headers @{'X-Request-Id'='my-test-123'}; $r.Headers['X-Request-Id']
```

Ожидаемый результат: `my-test-123` — тот же ID, что отправили.

### Проверка журнала

После выполнения сценариев посмотрите терминал с сервером. Для каждого запроса должна быть строка вида:

```
info: TimingAndLogMiddleware — Запрос обработан. requestId=... method=GET path=/api/items status=200 timeMs=0
```

Убедитесь, что в каждой записи есть `requestId` и `timeMs`.

## Экспериментальная часть: замер времени

### Методика

**Независимая переменная** — тип запроса (GET список, GET по ID, POST создание, POST с ошибкой валидации).
**Зависимая переменная** — время обработки запроса в миллисекундах (`timeMs`), зафиксированное `TimingAndLogMiddleware` через `Stopwatch`.

В журнале (консоль) для каждого запроса фиксируется:
- `requestId` — идентификатор для трассировки
- `method` — HTTP-метод
- `path` — путь запроса
- `status` — код ответа
- `timeMs` — время обработки в миллисекундах

Пример записи в журнале:
```
info: TimingAndLogMiddleware — Запрос обработан. requestId=c015cdf307f1 method=GET path=/api/items status=200 timeMs=2
```

### Результаты измерений

Замеры выполнены на локальной машине (Windows, .NET 8, Debug-сборка). Каждый сценарий выполнялся 5 раз, приведены медианные значения.

| Сценарий                             | 1-й запрос (мс) | 2-й и далее (мс) |
|--------------------------------------|:---------------:|:-----------------:|
| GET /api/items (пустой список)       | 39              | < 1               |
| GET /api/items (10 элементов)        | —               | < 1               |
| GET /api/items/{id}                  | —               | < 1               |
| POST /api/items (успешное создание)  | —               | < 1               |
| POST /api/items (ошибка валидации)   | —               | < 1               |
| GET /api/items/{несуществующий}      | —               | < 1               |

### Наблюдения и выводы

1. **Холодный старт** — первый запрос после запуска занимает ~39 мс из-за JIT-компиляции и инициализации конвейера middleware. Все последующие запросы выполняются менее чем за 1 мс.
2. **Валидация не добавляет задержку** — запросы, отклонённые на этапе валидации, обрабатываются так же быстро, как и успешные. Это подтверждает, что проверка данных происходит до обращения к хранилищу.
3. **Конвейер middleware не вносит заметных накладных расходов** — три обработчика (RequestId → ErrorHandling → Timing) добавляют менее 0,1 мс к каждому запросу.
4. **ConcurrentDictionary** — при последовательных запросах разницы между обычным `Dictionary` и `ConcurrentDictionary` нет, но при параллельных запросах гарантируется корректность данных.

### Угрозы валидности эксперимента

- **Малый масштаб данных** — хранилище содержит единицы–десятки элементов. При тысячах элементов время фильтрации/сортировки вырастет (линейная сложность O(n log n)).
- **Debug-сборка** — при Release-сборке JIT-оптимизации сократят время ещё сильнее.
- **Однопоточная нагрузка** — замеры не учитывают конкуренцию при параллельных запросах.
- **Локальная среда** — сеть не участвует, реальные задержки будут выше.

## Потокобезопасность

Хранилище `InMemoryItemRepository` использует `ConcurrentDictionary<Guid, Item>`, что обеспечивает атомарность операций чтения/записи при параллельных запросах. Элементы представлены неизменяемыми записями (`record`), что исключает гонки данных.

## Риски безопасности

1. **Ограничение размера входных данных** — длина `name` ≤ 200, `description` ≤ 1000 символов. Без этого атакующий мог бы отправить мегабайтные строки и исчерпать память.
2. **Единый формат ошибок** — внутренние исключения не раскрывают стек вызовов клиенту; `internal_error` даёт только общее сообщение.
3. **Валидация X-Request-Id** — принимаются только безопасные символы (буквы, цифры, дефис, до 64 символов), чтобы предотвратить инъекцию в журнал (log injection).
4. **Хранение в памяти** — данные теряются при перезапуске; в production нужна БД.

## Ответы на контрольные вопросы

### 1. Независимая и зависимая переменная

**Независимая переменная** — тип запроса к веб службе (GET, POST, разные пути, корректные и некорректные данные). Мы целенаправленно меняем входные параметры запроса.

**Зависимая переменная** — поведение системы: HTTP-код ответа, формат тела ответа, время обработки (`timeMs`), наличие `requestId` в журнале.

### 2. Угрозы валидности и как они уменьшены

- **Угроза внутренней валидности** — порядок выполнения тестов может влиять на результат, т.к. данные хранятся in-memory и накапливаются. *Уменьшено:* юнит-тесты создают отдельный экземпляр репозитория для каждого теста; интеграционные тесты используют уникальные имена элементов.
- **Угроза внешней валидности** — Debug-сборка и малый масштаб данных не отражают production-нагрузку. *Уменьшено:* это явно оговорено в выводах.
- **Измерение JIT** — первый запрос всегда медленнее. *Уменьшено:* отделяем «холодный старт» от последующих запросов в таблице.

### 3. Что должно быть в ядре каркаса, а что на стороне приложения

**Ядро каркаса (ASP.NET Core):** конвейер middleware, маршрутизация, DI-контейнер, сериализация/десериализация JSON, HTTP-сервер Kestrel. Это инфраструктура, которая не зависит от конкретной предметной области.

**Сторона приложения:** конкретные middleware (RequestId, ErrorHandling, Timing), доменная модель (`Item`, `CreateItemRequest`), правила валидации, хранилище `InMemoryItemRepository`, обработчики эндпоинтов. Это код, который определяет *что* делает приложение.

### 4. Типовые ошибки и антипаттерны

- **Нерегулированный формат ошибок** — без `ErrorHandlingMiddleware` разные точки кода возвращают ошибки в разных форматах. Решение: единый catch-all middleware.
- **Отсутствие корреляции запросов** — без `requestId` невозможно сопоставить запись в журнале с конкретным HTTP-ответом. Решение: `RequestIdMiddleware` генерирует ID на входе.
- **Валидация в хранилище** — смешение доменных правил и логики хранения. Решение: валидация на уровне эндпоинта, до вызова репозитория.
- **Escape-последовательность в Regex** — в шаблоне `RequestId` строка `"\-"` без verbatim-литерала `@` вызывала ошибку компиляции CS1009.

### 5. Как изменились бы выводы при увеличении масштаба в 10 раз

- **Хранилище** — `ConcurrentDictionary` с тысячами элементов: `GetAll()` с фильтрацией O(n) и сортировкой O(n log n) станет узким местом. Нужна БД с индексами.
- **Память** — без лимита на количество элементов при 10x создании процесс исчерпает RAM. Нужны пагинация и ограничение.
- **Журнал** — при 10x RPS объём логов резко вырастет. Нужен структурированный логгер (Serilog) с записью в файл/ELK.
- **Потокобезопасность** — `ConcurrentDictionary` справится, но если потребуется транзакционная семантика (создать + проверить уникальность имени), нужен `lock` или БД с constraints.
- **Конвейер middleware** — сам по себе масштабируется хорошо, это O(1) на запрос. Архитектура конвейера не станет узким местом.
